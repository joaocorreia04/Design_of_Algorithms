<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA - Project 2: DeliveryManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA - Project 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_delivery_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DeliveryManager Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcfa0a37fee9e2de2055e02a76c82a29"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#adcfa0a37fee9e2de2055e02a76c82a29">createDistanceMatrix</a> ()</td></tr>
<tr class="memdesc:adcfa0a37fee9e2de2055e02a76c82a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a distance matrix for the graph.  <a href="class_delivery_manager.html#adcfa0a37fee9e2de2055e02a76c82a29">More...</a><br /></td></tr>
<tr class="separator:adcfa0a37fee9e2de2055e02a76c82a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1559bb04c45cf1d43bc3d5d2e219999"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#ab1559bb04c45cf1d43bc3d5d2e219999">loadGraph</a> ()</td></tr>
<tr class="memdesc:ab1559bb04c45cf1d43bc3d5d2e219999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a graph based on user input.  <a href="class_delivery_manager.html#ab1559bb04c45cf1d43bc3d5d2e219999">More...</a><br /></td></tr>
<tr class="separator:ab1559bb04c45cf1d43bc3d5d2e219999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130c47cf152d252302d6225eefefa0da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a130c47cf152d252302d6225eefefa0da">loadToyGraph</a> ()</td></tr>
<tr class="memdesc:a130c47cf152d252302d6225eefefa0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a toy graph based on user input.  <a href="class_delivery_manager.html#a130c47cf152d252302d6225eefefa0da">More...</a><br /></td></tr>
<tr class="separator:a130c47cf152d252302d6225eefefa0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b13b6705536b1a77f333e45ab131940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a0b13b6705536b1a77f333e45ab131940">loadRealGraph</a> ()</td></tr>
<tr class="memdesc:a0b13b6705536b1a77f333e45ab131940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a real-world graph based on user input.  <a href="class_delivery_manager.html#a0b13b6705536b1a77f333e45ab131940">More...</a><br /></td></tr>
<tr class="separator:a0b13b6705536b1a77f333e45ab131940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34e1cc3e54cfdace458dcc34888dd4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#ad34e1cc3e54cfdace458dcc34888dd4e">loadFulCon</a> ()</td></tr>
<tr class="memdesc:ad34e1cc3e54cfdace458dcc34888dd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a fully connected graph based on user input.  <a href="class_delivery_manager.html#ad34e1cc3e54cfdace458dcc34888dd4e">More...</a><br /></td></tr>
<tr class="separator:ad34e1cc3e54cfdace458dcc34888dd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10c77e84a7aaee2612e230465efe30d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#af10c77e84a7aaee2612e230465efe30d">readToyGraph</a> (const string &amp;edges)</td></tr>
<tr class="memdesc:af10c77e84a7aaee2612e230465efe30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a toy graph from a file.  <a href="class_delivery_manager.html#af10c77e84a7aaee2612e230465efe30d">More...</a><br /></td></tr>
<tr class="separator:af10c77e84a7aaee2612e230465efe30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b9ddd358db132527f09bcd3adbe231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#ae4b9ddd358db132527f09bcd3adbe231">readRealGraph</a> (const string &amp;nodes, const string &amp;edges)</td></tr>
<tr class="memdesc:ae4b9ddd358db132527f09bcd3adbe231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a real-world graph from two files.  <a href="class_delivery_manager.html#ae4b9ddd358db132527f09bcd3adbe231">More...</a><br /></td></tr>
<tr class="separator:ae4b9ddd358db132527f09bcd3adbe231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88484960a4b06b6f4e816ceecc69d016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a88484960a4b06b6f4e816ceecc69d016">readFulCon</a> (const string &amp;nodes, const string &amp;edges, int num_of_nodes)</td></tr>
<tr class="memdesc:a88484960a4b06b6f4e816ceecc69d016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a fully connected graph from two files.  <a href="class_delivery_manager.html#a88484960a4b06b6f4e816ceecc69d016">More...</a><br /></td></tr>
<tr class="separator:a88484960a4b06b6f4e816ceecc69d016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd398d441caa7841dd388d0852de59ae"><td class="memItemLeft" align="right" valign="top"><a id="afd398d441caa7841dd388d0852de59ae" name="afd398d441caa7841dd388d0852de59ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printToy</b> ()</td></tr>
<tr class="separator:afd398d441caa7841dd388d0852de59ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3954aeaa7ff1dd73e43d3c2a731c87ee"><td class="memItemLeft" align="right" valign="top"><a id="a3954aeaa7ff1dd73e43d3c2a731c87ee" name="a3954aeaa7ff1dd73e43d3c2a731c87ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printReal</b> ()</td></tr>
<tr class="separator:a3954aeaa7ff1dd73e43d3c2a731c87ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093460da6be6abeb475270819c1b3b48"><td class="memItemLeft" align="right" valign="top"><a id="a093460da6be6abeb475270819c1b3b48" name="a093460da6be6abeb475270819c1b3b48"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printFulCon</b> (string n)</td></tr>
<tr class="separator:a093460da6be6abeb475270819c1b3b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b67178335a4465d0d1a82cf05e575a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a19b67178335a4465d0d1a82cf05e575a">apply_algorithm</a> ()</td></tr>
<tr class="memdesc:a19b67178335a4465d0d1a82cf05e575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a selected algorithm to the graph.  <a href="class_delivery_manager.html#a19b67178335a4465d0d1a82cf05e575a">More...</a><br /></td></tr>
<tr class="separator:a19b67178335a4465d0d1a82cf05e575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b704146efe3451f4aac5c60199840d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#aa2b704146efe3451f4aac5c60199840d">backtracking</a> ()</td></tr>
<tr class="memdesc:aa2b704146efe3451f4aac5c60199840d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Backtracking algorithm to the graph.  <a href="class_delivery_manager.html#aa2b704146efe3451f4aac5c60199840d">More...</a><br /></td></tr>
<tr class="separator:aa2b704146efe3451f4aac5c60199840d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617b17ce8ab530a86e6f9501aab59571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a617b17ce8ab530a86e6f9501aab59571">backtrackingAux</a> (Vertex&lt; int &gt; *&amp;v, std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;path, double &amp;cost, double &amp;minCost, std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;bestPath)</td></tr>
<tr class="memdesc:a617b17ce8ab530a86e6f9501aab59571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function for the Backtracking algorithm.  <a href="class_delivery_manager.html#a617b17ce8ab530a86e6f9501aab59571">More...</a><br /></td></tr>
<tr class="separator:a617b17ce8ab530a86e6f9501aab59571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22897bb78d4b65e15260fb227218c762"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a22897bb78d4b65e15260fb227218c762">triangularApproximation</a> ()</td></tr>
<tr class="memdesc:a22897bb78d4b65e15260fb227218c762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Triangular Approximation heuristic to the graph.  <a href="class_delivery_manager.html#a22897bb78d4b65e15260fb227218c762">More...</a><br /></td></tr>
<tr class="separator:a22897bb78d4b65e15260fb227218c762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551ea06508b2b9f4194f279f3b773483"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a551ea06508b2b9f4194f279f3b773483">preOrder</a> (vector&lt; Vertex&lt; int &gt; * &gt; &amp;path, Vertex&lt; int &gt; *&amp;current)</td></tr>
<tr class="memdesc:a551ea06508b2b9f4194f279f3b773483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a pre-order traversal of the graph and calculates the total distance of the path.  <a href="class_delivery_manager.html#a551ea06508b2b9f4194f279f3b773483">More...</a><br /></td></tr>
<tr class="separator:a551ea06508b2b9f4194f279f3b773483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ad9449c0777c93bce148043629fca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a94ad9449c0777c93bce148043629fca6">primMinimumCostSpanningTree</a> ()</td></tr>
<tr class="memdesc:a94ad9449c0777c93bce148043629fca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Prim's algorithm to the graph to find the minimum cost spanning tree.  <a href="class_delivery_manager.html#a94ad9449c0777c93bce148043629fca6">More...</a><br /></td></tr>
<tr class="separator:a94ad9449c0777c93bce148043629fca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff37f508f3951b3b3b8b6a500ef67ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#aff37f508f3951b3b3b8b6a500ef67ce0">nearestNeighbor</a> (int startvertex, vector&lt; Vertex&lt; int &gt; * &gt; &amp;path, double &amp;distance)</td></tr>
<tr class="memdesc:aff37f508f3951b3b3b8b6a500ef67ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Nearest Neighbor heuristic to the graph.  <a href="class_delivery_manager.html#aff37f508f3951b3b3b8b6a500ef67ce0">More...</a><br /></td></tr>
<tr class="separator:aff37f508f3951b3b3b8b6a500ef67ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415ab04edabbc6a7ed715bf768d4daef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#a415ab04edabbc6a7ed715bf768d4daef">reverseSubpath</a> (vector&lt; Vertex&lt; int &gt; * &gt; &amp;path, int i, int j)</td></tr>
<tr class="memdesc:a415ab04edabbc6a7ed715bf768d4daef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses a subpath of a given path.  <a href="class_delivery_manager.html#a415ab04edabbc6a7ed715bf768d4daef">More...</a><br /></td></tr>
<tr class="separator:a415ab04edabbc6a7ed715bf768d4daef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0edb65bc280f11161e697a181d7aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#abb0edb65bc280f11161e697a181d7aa8">linKernighan</a> (vector&lt; Vertex&lt; int &gt; * &gt; &amp;path, double &amp;distance)</td></tr>
<tr class="memdesc:abb0edb65bc280f11161e697a181d7aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Lin-Kernighan heuristic to the graph.  <a href="class_delivery_manager.html#abb0edb65bc280f11161e697a181d7aa8">More...</a><br /></td></tr>
<tr class="separator:abb0edb65bc280f11161e697a181d7aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebe728dd23a29b5ce9419bae4588918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#adebe728dd23a29b5ce9419bae4588918">LK</a> ()</td></tr>
<tr class="memdesc:adebe728dd23a29b5ce9419bae4588918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Lin-Kernighan heuristic to the graph and prints the results.  <a href="class_delivery_manager.html#adebe728dd23a29b5ce9419bae4588918">More...</a><br /></td></tr>
<tr class="separator:adebe728dd23a29b5ce9419bae4588918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaef30f5e07cc060e324bc1abf042d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#aceaaef30f5e07cc060e324bc1abf042d">solveTSPRealWorld</a> (int startVertex)</td></tr>
<tr class="memdesc:aceaaef30f5e07cc060e324bc1abf042d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Travelling Salesman Problem (TSP) for a real-world scenario.  <a href="class_delivery_manager.html#aceaaef30f5e07cc060e324bc1abf042d">More...</a><br /></td></tr>
<tr class="separator:aceaaef30f5e07cc060e324bc1abf042d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15bd6c9785752ffb22d5f2d25a2bc7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_delivery_manager.html#aa15bd6c9785752ffb22d5f2d25a2bc7b">isGraphConnected</a> (int startVertex)</td></tr>
<tr class="memdesc:aa15bd6c9785752ffb22d5f2d25a2bc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the graph is connected starting from a given vertex.  <a href="class_delivery_manager.html#aa15bd6c9785752ffb22d5f2d25a2bc7b">More...</a><br /></td></tr>
<tr class="separator:aa15bd6c9785752ffb22d5f2d25a2bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a19b67178335a4465d0d1a82cf05e575a" name="a19b67178335a4465d0d1a82cf05e575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b67178335a4465d0d1a82cf05e575a">&#9670;&#160;</a></span>apply_algorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::apply_algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a selected algorithm to the graph. </p>
<p >This function presents a menu to the user with different algorithms to apply to the graph. The user is asked to select an option by entering a number. If the user's input is not a number or is not one of the presented options, an error message is printed and the function returns. If the input is a valid option, the corresponding algorithm is applied to the graph. For options 1 (Backtracking) and 3 (Lin-Kernighan), if the graph does not meet the requirements for the algorithm (more than 15 vertices for Backtracking, not fully connected for Lin-Kernighan), the user is asked if they want to continue.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(1). </dd></dl>

</div>
</div>
<a id="aa2b704146efe3451f4aac5c60199840d" name="aa2b704146efe3451f4aac5c60199840d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b704146efe3451f4aac5c60199840d">&#9670;&#160;</a></span>backtracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::backtracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Backtracking algorithm to the graph. </p>
<p >This function applies the Backtracking algorithm to the graph to find the shortest path that visits all vertices. It uses the <code>backtrackingAux</code> function to explore all possible paths. The function measures the time it takes to find the shortest path. If a path that visits all vertices is not found, it prints a message and the time it took to search for the path. If a path that visits all vertices is found, it prints the path, the total distance, and the time it took to find the path. After the function finishes, it asks the user to press any key to continue and then calls the <code>apply_algorithm</code> function.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n!). </dd></dl>

</div>
</div>
<a id="a617b17ce8ab530a86e6f9501aab59571" name="a617b17ce8ab530a86e6f9501aab59571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617b17ce8ab530a86e6f9501aab59571">&#9670;&#160;</a></span>backtrackingAux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::backtrackingAux </td>
          <td>(</td>
          <td class="paramtype">Vertex&lt; int &gt; *&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function for the Backtracking algorithm. </p>
<p >This function is an auxiliary function for the Backtracking algorithm. It is a recursive function that explores all possible paths in the graph, keeping track of the current path and its cost. If the cost of the current path is greater than the cost of the best path found so far, the function returns. If a path that visits all vertices is found, its cost is compared with the cost of the best path found so far. If it is less, the best path and its cost are updated. The function uses a priority queue to explore the edges in order of their weight, starting with the smallest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The current vertex. </td></tr>
    <tr><td class="paramname">path</td><td>The current path. </td></tr>
    <tr><td class="paramname">cost</td><td>The cost of the current path. </td></tr>
    <tr><td class="paramname">minCost</td><td>The cost of the best path found so far. </td></tr>
    <tr><td class="paramname">bestPath</td><td>The best path found so far.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n!). </dd></dl>

</div>
</div>
<a id="adcfa0a37fee9e2de2055e02a76c82a29" name="adcfa0a37fee9e2de2055e02a76c82a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfa0a37fee9e2de2055e02a76c82a29">&#9670;&#160;</a></span>createDistanceMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; DeliveryManager::createDistanceMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a distance matrix for the graph. </p>
<p >This function creates a distance matrix for the graph, where each entry (i, j) represents the distance between vertex i and vertex j. The distance is calculated using the <code>getDist</code> method of the graph. If there is no path between two vertices, the distance is set to -1.</p>
<dl class="section return"><dt>Returns</dt><dd>A 2D vector representing the distance matrix.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^2). </dd></dl>

</div>
</div>
<a id="aa15bd6c9785752ffb22d5f2d25a2bc7b" name="aa15bd6c9785752ffb22d5f2d25a2bc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15bd6c9785752ffb22d5f2d25a2bc7b">&#9670;&#160;</a></span>isGraphConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DeliveryManager::isGraphConnected </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startVertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the graph is connected starting from a given vertex. </p>
<p >This function uses Breadth-First Search (BFS) to traverse the graph. It starts from a given vertex, then repeatedly visits all unvisited neighbors of the current vertex. If all vertices are visited, the graph is connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertex</td><td>The starting vertex for the BFS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the graph is connected, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(V + E), where V is the number of vertices and E is the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="abb0edb65bc280f11161e697a181d7aa8" name="abb0edb65bc280f11161e697a181d7aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0edb65bc280f11161e697a181d7aa8">&#9670;&#160;</a></span>linKernighan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::linKernighan </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Lin-Kernighan heuristic to the graph. </p>
<p >This function applies the Lin-Kernighan heuristic to the graph to improve a given path. The heuristic iteratively reverses subpaths of the path to try to reduce the total distance. The function starts with the given path and distance as the best path and distance found so far. Then, it enters a loop that continues until no improvement can be made. In each iteration of the loop, it tries reversing each subpath of the best path found so far. If reversing a subpath results in a shorter path, the new path and distance become the best path and distance found so far, and the loop continues. If no subpath reversal results in a shorter path, the loop ends. Finally, the function updates the given path and distance with the best path and distance found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A reference to a vector where the path will be stored. </td></tr>
    <tr><td class="paramname">distance</td><td>A reference to a double where the total distance of the path will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^3), where n is the number of vertices in the path. This is because the function tries reversing each subpath of the path, and each reversal takes O(n) time. </dd></dl>

</div>
</div>
<a id="adebe728dd23a29b5ce9419bae4588918" name="adebe728dd23a29b5ce9419bae4588918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebe728dd23a29b5ce9419bae4588918">&#9670;&#160;</a></span>LK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::LK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Lin-Kernighan heuristic to the graph and prints the results. </p>
<p >This function applies the Lin-Kernighan heuristic to the graph to improve a path found by the Nearest Neighbor heuristic. It measures the time it takes to find the path and to improve it, and prints the path, the total distance, and the time it took. The function starts by marking all vertices as unvisited and then applies the Nearest Neighbor heuristic to find a path. If a path that visits all vertices is not found, it prints a message and the time it took, asks the user to press any key to continue, and then calls the <code>apply_algorithm</code> function. If a path is found, it prints the total distance and the time it took, and then applies the Lin-Kernighan heuristic to improve the path. Finally, it prints the improved total distance and the time it took to improve the path, asks the user to press any key to continue, and then calls the <code>apply_algorithm</code> function.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^3). </dd></dl>

</div>
</div>
<a id="ad34e1cc3e54cfdace458dcc34888dd4e" name="ad34e1cc3e54cfdace458dcc34888dd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34e1cc3e54cfdace458dcc34888dd4e">&#9670;&#160;</a></span>loadFulCon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::loadFulCon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a fully connected graph based on user input. </p>
<p >This function presents a menu to the user with different fully connected graphs to load. The user is asked to select an option by entering a number. If the user's input is not a number or is not one of the presented options, an error message is printed and the function returns. If the input is a valid option, the corresponding fully connected graph loading function is called. For option 4, the user is asked to provide the number of nodes.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(1). </dd></dl>

</div>
</div>
<a id="ab1559bb04c45cf1d43bc3d5d2e219999" name="ab1559bb04c45cf1d43bc3d5d2e219999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1559bb04c45cf1d43bc3d5d2e219999">&#9670;&#160;</a></span>loadGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::loadGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a graph based on user input. </p>
<p >This function presents a menu to the user with different types of graphs to load. The user is asked to select an option by entering a number. If the user's input is not a number or is not one of the presented options, an error message is printed and the function returns. If the input is a valid option, the corresponding graph loading function is called.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(1). </dd></dl>

</div>
</div>
<a id="a0b13b6705536b1a77f333e45ab131940" name="a0b13b6705536b1a77f333e45ab131940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b13b6705536b1a77f333e45ab131940">&#9670;&#160;</a></span>loadRealGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::loadRealGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a real-world graph based on user input. </p>
<p >This function presents a menu to the user with different real-world graphs to load. The user is asked to select an option by entering a number. If the user's input is not a number or is not one of the presented options, an error message is printed and the function returns. If the input is a valid option, the corresponding real-world graph loading function is called. For option 4, the user is asked to provide the paths to the nodes and edges files.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(1). </dd></dl>

</div>
</div>
<a id="a130c47cf152d252302d6225eefefa0da" name="a130c47cf152d252302d6225eefefa0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130c47cf152d252302d6225eefefa0da">&#9670;&#160;</a></span>loadToyGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::loadToyGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a toy graph based on user input. </p>
<p >This function presents a menu to the user with different types of toy graphs to load. The user is asked to select an option by entering a number. If the user's input is not a number or is not one of the presented options, an error message is printed and the function returns. If the input is a valid option, the corresponding toy graph loading function is called.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(1). </dd></dl>

</div>
</div>
<a id="aff37f508f3951b3b3b8b6a500ef67ce0" name="aff37f508f3951b3b3b8b6a500ef67ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff37f508f3951b3b3b8b6a500ef67ce0">&#9670;&#160;</a></span>nearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::nearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startvertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Nearest Neighbor heuristic to the graph. </p>
<p >This function applies the Nearest Neighbor heuristic to the graph to find a path that visits all vertices. The heuristic starts from a given vertex and, at each step, visits the nearest unvisited vertex. The function uses a priority queue to keep track of the edges to explore, starting with the edge with the smallest weight. For each edge, if the destination vertex has not been visited, it is marked as visited, added to the path, and the weight of the edge is added to the total distance. The function continues until all vertices have been visited or there are no more edges to explore. Finally, it adds the starting vertex to the end of the path and adds the distance to the previous vertex in the path to the total distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A reference to a vector where the path will be stored. </td></tr>
    <tr><td class="paramname">distance</td><td>A reference to a double where the total distance of the path will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^2). </dd></dl>

</div>
</div>
<a id="a551ea06508b2b9f4194f279f3b773483" name="a551ea06508b2b9f4194f279f3b773483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551ea06508b2b9f4194f279f3b773483">&#9670;&#160;</a></span>preOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DeliveryManager::preOrder </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&lt; int &gt; *&amp;&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a pre-order traversal of the graph and calculates the total distance of the path. </p>
<p >This function performs a pre-order traversal of the graph starting from a given vertex. It keeps track of the path and the total distance. The function uses a stack to keep track of the vertices to visit. It starts by pushing the starting vertex onto the stack. Then, while the stack is not empty, it pops a vertex from the stack, adds it to the path, and marks it as visited. If the vertex is not the first one in the path, it calculates the distance to the previous vertex in the path and adds it to the total distance. The distance is calculated using the Haversine formula if it has not been calculated before. Then, it pushes all unvisited children of the vertex onto the stack. Finally, it adds the starting vertex to the end of the path and adds the distance to the previous vertex in the path to the total distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A reference to a vector where the path will be stored. </td></tr>
    <tr><td class="paramname">current</td><td>A reference to the starting vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the path.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n). </dd></dl>

</div>
</div>
<a id="a94ad9449c0777c93bce148043629fca6" name="a94ad9449c0777c93bce148043629fca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ad9449c0777c93bce148043629fca6">&#9670;&#160;</a></span>primMinimumCostSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::primMinimumCostSpanningTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Prim's algorithm to the graph to find the minimum cost spanning tree. </p>
<p >This function applies the Prim's algorithm to the graph to find the minimum cost spanning tree. It starts from the first vertex in the graph. The function uses a priority queue to keep track of the edges to explore, starting with the edge with the smallest weight. For each edge, if the destination vertex has not been visited, it is marked as visited and added to the tree. Then, for each unvisited vertex, if there is an edge from the destination vertex to the unvisited vertex, the edge is added to the priority queue. If there is no edge and the graph uses coordinates, the Haversine distance between the vertices is calculated and used as the weight of the edge. The function continues until all vertices have been visited.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(E log E), where E is the number of edges in the graph. This is because the function uses a priority queue to keep track of the edges to explore, and each insertion into a priority queue takes O(log E) time. </dd></dl>

</div>
</div>
<a id="a88484960a4b06b6f4e816ceecc69d016" name="a88484960a4b06b6f4e816ceecc69d016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88484960a4b06b6f4e816ceecc69d016">&#9670;&#160;</a></span>readFulCon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::readFulCon </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_of_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a fully connected graph from two files. </p>
<p >This function reads a fully connected graph from two files. One file should contain the nodes of the graph, with each line representing a node. Each line should be in the format "ID, Longitude, Latitude". The other file should contain the edges of the graph, with each line representing an edge. Each line should be in the format "Origin, Destination, Weight". The function first clears the current graph and then reads the nodes and edges from the files, adding the vertices and edges to the graph. If the number of edges is equal to the number of vertices choose 2 (n*(n-1)/2), it sets the <code>fullyConnected</code> attribute of the graph to true. Finally, it creates a distance matrix for the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>The path to the file containing the nodes of the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>The path to the file containing the edges of the graph. </td></tr>
    <tr><td class="paramname">num_of_nodes</td><td>The number of nodes to read from the nodes file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^2). </dd></dl>

</div>
</div>
<a id="ae4b9ddd358db132527f09bcd3adbe231" name="ae4b9ddd358db132527f09bcd3adbe231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b9ddd358db132527f09bcd3adbe231">&#9670;&#160;</a></span>readRealGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::readRealGraph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a real-world graph from two files. </p>
<p >This function reads a real-world graph from two files. One file should contain the nodes of the graph, with each line representing a node. Each line should be in the format "ID, Longitude, Latitude". The other file should contain the edges of the graph, with each line representing an edge. Each line should be in the format "Origin, Destination, Weight". The function first clears the current graph and then reads the nodes and edges from the files, adding the vertices and edges to the graph. If the graph is fully connected, it sets the <code>fullyConnected</code> attribute of the graph to true. Finally, it creates a distance matrix for the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>The path to the file containing the nodes of the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>The path to the file containing the edges of the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^2). </dd></dl>

</div>
</div>
<a id="af10c77e84a7aaee2612e230465efe30d" name="af10c77e84a7aaee2612e230465efe30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10c77e84a7aaee2612e230465efe30d">&#9670;&#160;</a></span>readToyGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::readToyGraph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a toy graph from a file. </p>
<p >This function reads a toy graph from a file. The file should contain the edges of the graph, with each line representing an edge. Each line should be in the format "Origin, Destination, Weight". The function first clears the current graph and then reads the edges from the file, adding the vertices and edges to the graph. If the graph is fully connected, it sets the <code>fullyConnected</code> attribute of the graph to true. Finally, it creates a distance matrix for the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The path to the file containing the edges of the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^2). </dd></dl>

</div>
</div>
<a id="a415ab04edabbc6a7ed715bf768d4daef" name="a415ab04edabbc6a7ed715bf768d4daef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415ab04edabbc6a7ed715bf768d4daef">&#9670;&#160;</a></span>reverseSubpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::reverseSubpath </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Vertex&lt; int &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses a subpath of a given path. </p>
<p >This function reverses a subpath of a given path. The subpath is specified by two indices, i and j, with i &lt;= j. The function swaps the vertices at indices i and j, then increments i and decrements j, and continues until i &gt;= j.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A reference to a vector where the path is stored. </td></tr>
    <tr><td class="paramname">i</td><td>The starting index of the subpath. </td></tr>
    <tr><td class="paramname">j</td><td>The ending index of the subpath.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n). </dd></dl>

</div>
</div>
<a id="aceaaef30f5e07cc060e324bc1abf042d" name="aceaaef30f5e07cc060e324bc1abf042d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaaef30f5e07cc060e324bc1abf042d">&#9670;&#160;</a></span>solveTSPRealWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::solveTSPRealWorld </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startVertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Travelling Salesman Problem (TSP) for a real-world scenario. </p>
<p >This function uses the Nearest Neighbor heuristic to solve the TSP. It starts from a given vertex, then repeatedly visits the nearest unvisited vertex until all vertices have been visited. The path is then outputted along with the total distance and the time taken to compute the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startVertex</td><td>The starting vertex for the TSP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(n^2), where n is the number of vertices in the graph. </dd></dl>

</div>
</div>
<a id="a22897bb78d4b65e15260fb227218c762" name="a22897bb78d4b65e15260fb227218c762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22897bb78d4b65e15260fb227218c762">&#9670;&#160;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeliveryManager::triangularApproximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Triangular Approximation heuristic to the graph. </p>
<p >This function applies the Triangular Approximation heuristic to the graph to find a path that visits all vertices. The heuristic is based on the idea of creating a minimum cost spanning tree and then performing a pre-order traversal of the tree. The function measures the time it takes to find the path. If a path that visits all vertices is found, it prints the path, the total distance, and the time it took to find the path. After the function finishes, it asks the user to press any key to continue and then calls the <code>apply_algorithm</code> function.</p>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(E log E + n), where E is the number of edges in the graph and n is the number of vertices. This is because the function uses Prim's algorithm to create a minimum cost spanning tree (O(E log E)) and then performs a pre-order traversal of the tree (O(n)). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_delivery_manager_8h_source.html">DeliveryManager.h</a></li>
<li>DeliveryManager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
